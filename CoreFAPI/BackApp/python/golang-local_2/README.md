# Сервис регистрации и авторизации

Прежде чем запушить код в репозиторий:
- выполнить команду `make go-fmt` **которая приведет код к единому стилю**
- выполнить команду `make go-memory-check` и если она что-то найдет, выполнить команду `make go-memory-fix` **которая оптимизирует потребление памяти (Memory Alignment / выравнивание памяти)**
- выполнить команду `make go-lint` **которая прогонит все линтеры, если она что-то найдет, то исправляйте!** Конечно, этого можно и не делать, игнорировать линтеры, но в долгосрочной работе, мы все потеряем время


## Работа с сервисом
Для просмотра докуменатции - запустите сервис и перейдите по `http://localhost:8010/swagger/index.html`.

<u>**Доступные ручки**</u>

Auth:
 - /register [POST] -> создать пользователя
 - /login [POST] -> выполнить вход по почте и паролю, создает сессию в Redis и записывает id сессии в куки
 - /logout [POST] -> `защищенная` выход, удялет сессию в Redis и очщает куки

User:
 - /user [GET]  -> `защищенная` получить пользователя
 - /user [PUT]  -> `защищенная` обновить данные пользователя
 - /user [DELETE]  -> `защищенная` удалить пользователя и сессию

Data:
 - /data/u/{uuid} [GET] -> получить пользователя по uuid

Для тестов используются моки, конкретно - `"github.com/golang/mock/gomock"`. Они генерируются автоматически, нужно только перед интерфейсом написать `//go:generate mockgen`

Для генерации через mockgen нужен отдельный иструмент `go install github.com/golang/mock/mockgen@latest`, он может быть у вас уже установлен, проверить это `mockgen --version`

Для генерации полная команда выгдяит так: `//go:generate mockgen -source=$GOFILE -destination=mocks/mock_iusersrepo.go -package=mocks`
 - флаг -source=$GOFILE переменная, которая указывает на текущий файл.
 - -destination=путь к файлу, куда будет сохранён сгенерированный мок
 - -package=ия пакета, в котором будет находиться мок

Старайтесь группировать моки. Т.е. все моки, всех репозиториев - в своем пакете, все моки, всех обработчиков - в своем пакете, все моки юзкейсов - в своем пакете. Чтобы они собиралсь в одном месте для каждого слоя, а не были разбросаны в разных местах. 

## Как это работает?
- Все начинается в `main.go` - читается <u>конфиг</u> и создается <u>логгер</u>.

- Далее - <u>конфиг</u> и <u>логгер</u> передаются в `App.go` для подключения к <u>postgres</u> и <u>redis</u>.

- Далее - создается сам HTTP-сервер, он получает <u>конфиг HTTP</u>, <u>логгер</u>, <u>postgres</u> и <u>redis</u>. Все это используестя в `server.go` для создания <u>обработчиков</u>, <u>middleware's</u>, <u>репозиториев</u>, <u>юзкейсов</u>.
	- Конкретно репозитории: каждый из них получает <u>логгер</u>, и свою базу данных с которой будет рабоать. `SessionsRepo` - redis, `PostgresUserRepo` - postgres.
	- Конкретно юзкейсы: кейсы для users и кейсы для auth. Каждый из них получает <u>логгер</u> и нужные им <u>репозитории</u>.
	- Конкретно обработчки: создается `baseHandler.go`, он получает <u>логгер</u>. Потом, создаются все остальные обработчики, они, каждый, получают `baseHandler.go` и нужные им <u>юзкейсы</u>. 
	- Конкретно middleware's: каждый из них получает <u>логгер</u>, а `MiddlewareAuth` еще и `SessionsRepo`, так как он будет проверять есть ли активная сессия.
	- <u>Обработчики</u> и <u>middleware's</u> отправляются в`initRouters.go`и происходит инициализация путей, где каждый путь получает логгирование через middleware, нужные ручки получают защиту через `MiddlewareAuth` и в конце, сам обработчик, а именно - конкретный метод этого обработчика. 

- Далее - после создания HTTP-сервера и подключений к всему, что нужно, мы возвращаемся в `main.go`, где у нашего приложения, в отдельной горутине (это нужно, чтобы не блокировать поток), вызываем метод старт. Внутри этого метода и вызывается `ListenAndServe` у созданного ранее HTTP-сервера. Тут срабатывают middleware's, которые устанавливают таймауты HTTP и CORS. 

- Далее, код идет дальше и создает канал для фиксации сигналов о завершении программы. И на этом горутина main останавливается и ждет сигналов. Все, севрвис регистрации и авторизации работает! Можно отправлять запросы. 

- Когда сигналы о заврешении будут получены, у нашего приложения сработает метод стоп. В котором будут: остановлен HTTP-сервер (чтобы активные запросы успели завершиться), закрыты соединения с postgres и redis. 

## Как проходит конкретный запрос? 
Получение данных пользователя: 
- Встречает его `middleware Timeout`, который обогащает контекст запроса таймаутом на выполнение. Это нужно, чтобы запрос был ограничен по времени и не мог вызвать зависание где-то (у какой-то службы / севриса / БД) в приложении. Далее, этот таймаут будет передаваться в ВСЕ слои приложения. 
- Далее, начинает работать `middleware CORS`, который проверяет разрешения.
- Далее, начинает работать `MiddlewareLogging`, который логгирует запрос. И фиксирует время его начала. 
- Далее, начинает работать `MiddlewareAuth`, который проверяет наличие нужного ключа в куках, по нему извлекает нагрузку сессии из Redis. И записывает нужные данные из сессии (он же получил нагрузку) в контекст запроса.
- Далее, начинает работать `HandlerUser`, и конкретно - его метод `User()`.
- Далее, обработчик `HandlerUser` вызывает `юзкейс User`.
- Далее, `юзкейс User` вызввает метод репозитория `repo.FindUser()`.
- Далее, репозиторий ищет пользователя в postgres. <u>Это конечная точка, глубже вызовов не будет</u>. 
- Далее, полученные данные поднимаются обратно в `юзкейс User`.
- Далее, полученные данные поднимаются в `HandlerUser`.
- Далее, полученные данные отправляются из `HandlerUser` в `BaseHandler`, вызывая его метод записи JSON в ответ. 
- Ответ отправляется и `MiddlewareLogging` заканчивает свою работы выводя логи и время потраченное на запрос. 

Если, в каком-то слое, произошла ошибка, то она будет поднята до обработчика, который и запишет ее в ответ через `BaseHandler.HandleError()`.

## Структура
<pre>
│   <b>.golangci.yml</b> - Линтеры.
│   <b>configLocal.yaml</b> - Конфигурационный файл.
│   <b>docker-compose.yaml</b> - Сборка севриса в Docker.
│   <b>go.mod</b> - Файл зависимостей Go модуля.
│   <b>go.sum</b> - Хэши зависимостей Go модуля.
│   <b>Makefile</b> - Для автоматизации команд.
│   <b>README.md</b> - Документация проекта.
│
├───<u><i>cmd</i></u>
│   │   <b>main.go</b> - Точка входа в приложение, тут создается логгер, загружается конфигурация и далее, на основе этого, создается приложение.
│   │
│   └───<u><i>migrator</i></u>
│           <b>migrator.go</b> - Утилита для выполнения миграций.
│
├───<u><i>config</i></u>
│       <b>config.go</b> - Парсинг конфигурационных файлов.
│
├───<u><i>docs</i></u>
│       <b>docs.go</b> - Генерируемый файл документации Swagger.
│       <b>swagger.json</b> - JSON-представление Swagger-документации.
│       <b>swagger.yaml</b> - YAML-представление Swagger-документации.
│
├───<i><u>internal</i></u>
│   ├───<i><u>adapters</i></u> - тут собрано все, что работет с чем-то конкретным (базы данных к примеру)
│   │   ├───<i><u>http</i></u>
│   │   │   │   <b>baseHandler.go</b> - Базовый обработчик HTTP-запросов, он сам используется ТОЛЬКО ВНУТРИ чего-то.
│   │   │   │   <b>handlerAuth.go</b> - Обработчики для регистрации, аутентификации и авторизации.
│   │   │   │   <b>handlerUser.go</b> - Обработчики для операций с пользователями.
│   │   │   │
│   │   │   ├───<i><u>cookie</i></u>
│   │   │   │       <b>cookie.go</b> - Настройка куков.
│   │   │   │
│   │   │   └───<i><u>httpMiddleware</i></u>
│   │   │           <b>auth.go</b> - Middleware для проверки авторизации.
│   │   │           <b>logging.go</b> - Middleware для логирования HTTP-запросов.
│   │   │
│   │   └───<i><u>repository </i></u>
│   │       ├───<i><u>sessionsRepo</i></u>
│   │       │       <b>sessionsRepo.go</b> - Репозиторий для работы с сессиями (в данном случае - Redis).
│   │       │
│   │       └───<i><u>userRepo</i></u>
│   │               <b>userRepo.go</b> - Репозиторий для работы с пользователями (в данном случае - PostgreSQL).
│   │
│   ├───<i><u>app</i></u>
│   │       <b>app.go</b> - Инкапсуляция всей логики работы внутри "приложения". Тут происходит: подключение к строннним службам, старт и стоп.
│   ├───<i><u>dto</i></u>
│   │       <b>dto.go</b> - Data Transfer Objects (DTO) для передачи данных между слоями.
│   │
│   ├───<i><u>entity</i></u>
│   │       <b>user.go</b> - Определение сущности "Пользователь".
│   │
│   ├───<i><u>server</i></u>
│   │       <b>initRouters.go</b> - Инициализация маршрутов HTTP-сервера.
│   │       <b>server.go</b> - Настройка и запуск HTTP-сервера. Тут создаются: обработчики, middleware, репозитории для конкретных задач. 
│   │
│   └───<i><u>usecase</i></u>
│           <b>auth.go</b> - Логика регистрации, аутентификации и авторизации.
│           <b>user.go</b> - Логика для операций с пользователями.
│
├───<i><u>migrations</i></u> - миграции дл БД
│       1_init.down.sql
│       1_init.up.sql
│
└───<i><u>pkg</i></u>
    ├───<i><u>db</i></u>
    │   ├───<i><u>postgres</i></u>
    │   │       <b>connect.go</b> - Подключения к PostgreSQL.
    │   │
    │   └───<i><u>redis</i></u>
    │           <b>connect.go</b> - Подключения к Redis.
    │
    ├───<i><u>error</i></u>
    │       <b>error.go</b> - Кастомные ошибки для этого севриса.
    │
    ├───<i><u>logs</i></u>
    │       <b>logger.go</b> - Настройка логгера (в данном случае - обертка над slog).
    │       <b>slogdiscard.go</b> - Утилита для игнорирования логов, нужно для тестов (логгер как зависимость), чтобы логгер никуда не писал.
    │
    ├───<i><u>middleware</i></u>
    │       <b>chain.go</b> - Создание цепочки middleware's.
    │       <b>cors.go</b> - Middleware для настройки CORS.
    │       <b>timeouts.go</b> - Middleware для обработки таймаутов HTTP-сервера.
    │
    ├───<i><u>utils</i></u>
    │       <b>utils.go</b> - Вспомогательные функции.
    │
    └───<i><u>validate</i></u>
            <b>validate.go</b> - Для валидации данных.
</pre>